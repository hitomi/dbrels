export const parser = // @generated by Peggy 3.0.2.
  //
  // https://peggyjs.org/
  (function () {
    "use strict";

    function peg$subclass(child, parent) {
      function C() { this.constructor = child; }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }

    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      // istanbul ignore next Check is a necessary evil to support older environments
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }

    peg$subclass(peg$SyntaxError, Error);

    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) { return str; }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }

    peg$SyntaxError.prototype.format = function (sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s = this.location.start;
        var offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
          ? this.location.source.offset(s)
          : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", offset_s.line.toString().length, ' ');
          var line = src[s.line - 1];
          var last = s.line === e.line ? e.column : line.length + 1;
          var hatLen = (last - s.column) || 1;
          str += "\n --> " + loc + "\n"
            + filler + " |\n"
            + offset_s.line + " | " + line + "\n"
            + filler + " | " + peg$padEnd("", s.column - 1, ' ')
            + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };

    peg$SyntaxError.buildMessage = function (expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function (expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        class: function (expectation) {
          var escapedParts = expectation.parts.map(function (part) {
            return Array.isArray(part)
              ? classEscape(part[0]) + "-" + classEscape(part[1])
              : classEscape(part);
          });

          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },

        any: function () {
          return "any character";
        },

        end: function () {
          return "end of input";
        },

        other: function (expectation) {
          return expectation.description;
        }
      };

      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }

      function literalEscape(s) {
        return s
          .replace(/\\/g, "\\\\")
          .replace(/"/g, "\\\"")
          .replace(/\0/g, "\\0")
          .replace(/\t/g, "\\t")
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "\\r")
          .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
      }

      function classEscape(s) {
        return s
          .replace(/\\/g, "\\\\")
          .replace(/\]/g, "\\]")
          .replace(/\^/g, "\\^")
          .replace(/-/g, "\\-")
          .replace(/\0/g, "\\0")
          .replace(/\t/g, "\\t")
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "\\r")
          .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
          .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
      }

      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }

      function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation);
        var i, j;

        descriptions.sort();

        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }

        switch (descriptions.length) {
          case 1:
            return descriptions[0];

          case 2:
            return descriptions[0] + " or " + descriptions[1];

          default:
            return descriptions.slice(0, -1).join(", ")
              + ", or "
              + descriptions[descriptions.length - 1];
        }
      }

      function describeFound(found) {
        return found ? "\"" + literalEscape(found) + "\"" : "end of input";
      }

      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };

    function peg$parse(input, options) {
      options = options !== undefined ? options : {};

      var peg$FAILED = {};
      var peg$source = options.grammarSource;

      var peg$startRuleFunctions = { Schema: peg$parseSchema };
      var peg$startRuleFunction = peg$parseSchema;

      var peg$c0 = "{";
      var peg$c1 = "}";
      var peg$c2 = "?";
      var peg$c3 = ":";
      var peg$c4 = ".";
      var peg$c5 = "(";
      var peg$c6 = ",";
      var peg$c7 = ")";
      var peg$c8 = "\"";
      var peg$c9 = "=";
      var peg$c10 = "table";
      var peg$c11 = "->";

      var peg$r0 = /^[^,"=]/;
      var peg$r1 = /^[a-zA-Z_]/;
      var peg$r2 = /^[a-zA-Z0-9_]/;
      var peg$r3 = /^[ \t\n\r]/;
      var peg$r4 = /^[\n\r]/;
      var peg$r5 = /^[ \t]/;

      var peg$e0 = peg$literalExpectation("{", false);
      var peg$e1 = peg$literalExpectation("}", false);
      var peg$e2 = peg$literalExpectation("?", false);
      var peg$e3 = peg$literalExpectation(":", false);
      var peg$e4 = peg$literalExpectation(".", false);
      var peg$e5 = peg$literalExpectation("(", false);
      var peg$e6 = peg$literalExpectation(",", false);
      var peg$e7 = peg$literalExpectation(")", false);
      var peg$e8 = peg$literalExpectation("\"", false);
      var peg$e9 = peg$literalExpectation("=", false);
      var peg$e10 = peg$classExpectation([",", "\"", "="], true, false);
      var peg$e11 = peg$classExpectation([["a", "z"], ["A", "Z"], "_"], false, false);
      var peg$e12 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_"], false, false);
      var peg$e13 = peg$otherExpectation("keyword");
      var peg$e14 = peg$otherExpectation("table");
      var peg$e15 = peg$literalExpectation("table", false);
      var peg$e16 = peg$literalExpectation("->", false);
      var peg$e17 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false);
      var peg$e18 = peg$classExpectation(["\n", "\r"], false, false);
      var peg$e19 = peg$classExpectation([" ", "\t"], false, false);
      var peg$e20 = peg$otherExpectation("whitespace");

      var peg$f0 = function (kind, name, list) { return { kind, name, attributes: list } };
      var peg$f1 = function (key, fg) { return fg };
      var peg$f2 = function (key, fg, opt, value, str) { return str };
      var peg$f3 = function (key, fg, opt, value, str) { return { name: key, type: value, optional: !!opt, flags: fg, extra: str || [] } };
      var peg$f4 = function (key, fg) { return fg };
      var peg$f5 = function (key, fg, opt, table, attribute, str) { return str };
      var peg$f6 = function (key, fg, opt, table, attribute, str) { return { name: key, ref: { table, attribute }, optional: !!opt, flags: fg, extra: str || [] } };
      var peg$f7 = function (f) { return f };
      var peg$f8 = function (kv) { return kv };
      var peg$f9 = function (k, v) { return { key: k, value: v } };
      var peg$f10 = function (s) { return s.join('') };
      var peg$f11 = function (h, r) { return [h, ...r].join('') };
      var peg$f12 = function () { return };
      var peg$f13 = function () { return };
      var peg$currPos = options.peg$currPos | 0;
      var peg$savedPos = peg$currPos;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = peg$currPos;
      var peg$maxFailExpected = options.peg$maxFailExpected || [];
      var peg$silentFails = options.peg$silentFails | 0;

      var peg$result;

      if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }

      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }

      function offset() {
        return peg$savedPos;
      }

      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }

      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }

      function expected(description, location) {
        location = location !== undefined
          ? location
          : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location
        );
      }

      function error(message, location) {
        location = location !== undefined
          ? location
          : peg$computeLocation(peg$savedPos, peg$currPos);

        throw peg$buildSimpleError(message, location);
      }

      function peg$literalExpectation(text, ignoreCase) {
        return { type: "literal", text: text, ignoreCase: ignoreCase };
      }

      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
      }

      function peg$anyExpectation() {
        return { type: "any" };
      }

      function peg$endExpectation() {
        return { type: "end" };
      }

      function peg$otherExpectation(description) {
        return { type: "other", description: description };
      }

      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;

        if (details) {
          return details;
        } else {
          if (pos >= peg$posDetailsCache.length) {
            p = peg$posDetailsCache.length - 1;
          } else {
            p = pos;
            while (!peg$posDetailsCache[--p]) { }
          }

          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };

          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }

            p++;
          }

          peg$posDetailsCache[pos] = details;

          return details;
        }
      }

      function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);

        var res = {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
        if (offset && peg$source && (typeof peg$source.offset === "function")) {
          res.start = peg$source.offset(res.start);
          res.end = peg$source.offset(res.end);
        }
        return res;
      }

      function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) { return; }

        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
      }

      function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
      }

      function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected, found),
          expected,
          found,
          location
        );
      }

      function peg$parseSchema() {
        var s0, s1, s2;

        s0 = [];
        s1 = peg$parseBlock();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          s2 = peg$parse_();
          s2 = peg$parseBlock();
          if (s2 === peg$FAILED) {
            peg$currPos = s1;
            s1 = peg$FAILED;
          } else {
            s1 = s2;
          }
        }

        return s0;
      }

      function peg$parseBlock() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

        s0 = peg$currPos;
        s1 = peg$parseTable();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseName();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 123) {
                s5 = peg$c0;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e0); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                s7 = peg$parseList();
                s8 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 125) {
                  s9 = peg$c1;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e1); }
                }
                if (s9 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f0(s1, s3, s7);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseList() {
        var s0, s1, s2, s3, s4, s5;

        s0 = [];
        s1 = peg$parseColumn();
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          s2 = peg$currPos;
          s3 = peg$parseSpace();
          s4 = peg$parseLineBreak();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSpace();
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s2 = peg$parseColumn();
            if (s2 === peg$FAILED) {
              peg$currPos = s1;
              s1 = peg$FAILED;
            } else {
              s1 = s2;
            }
          } else {
            s1 = s2;
          }
        }

        return s0;
      }

      function peg$parseColumn() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

        s0 = peg$currPos;
        s1 = peg$parseName();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseSpace();
          s4 = peg$parseFlagGroup();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseSpace();
            peg$savedPos = s2;
            s2 = peg$f1(s1, s4);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c2;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e2); }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          s5 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 58) {
            s6 = peg$c3;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e3); }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parse_();
            s8 = peg$parseName();
            if (s8 !== peg$FAILED) {
              s9 = peg$currPos;
              s10 = peg$parseHardSpace();
              if (s10 !== peg$FAILED) {
                s11 = peg$parseStrOpts();
                if (s11 !== peg$FAILED) {
                  peg$savedPos = s9;
                  s9 = peg$f2(s1, s2, s4, s8, s11);
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              } else {
                peg$currPos = s9;
                s9 = peg$FAILED;
              }
              if (s9 === peg$FAILED) {
                s9 = null;
              }
              peg$savedPos = s0;
              s0 = peg$f3(s1, s2, s4, s8, s9);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseName();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseSpace();
            s4 = peg$parseFlagGroup();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSpace();
              peg$savedPos = s2;
              s2 = peg$f4(s1, s4);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 63) {
              s4 = peg$c2;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e2); }
            }
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            s5 = peg$parse_();
            s6 = peg$parseArrow();
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              s8 = peg$parseName();
              if (s8 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s9 = peg$c4;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$e4); }
                }
                if (s9 !== peg$FAILED) {
                  s10 = peg$parseName();
                  if (s10 !== peg$FAILED) {
                    s11 = peg$currPos;
                    s12 = peg$parseHardSpace();
                    if (s12 !== peg$FAILED) {
                      s13 = peg$parseStrOpts();
                      if (s13 !== peg$FAILED) {
                        peg$savedPos = s11;
                        s11 = peg$f5(s1, s2, s4, s8, s10, s13);
                      } else {
                        peg$currPos = s11;
                        s11 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s11;
                      s11 = peg$FAILED;
                    }
                    if (s11 === peg$FAILED) {
                      s11 = null;
                    }
                    peg$savedPos = s0;
                    s0 = peg$f6(s1, s2, s4, s8, s10, s11);
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }

        return s0;
      }

      function peg$parseFlagGroup() {
        var s0, s1, s2, s3, s4, s5, s6, s7;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c5;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e5); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseName();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            s5 = peg$parseSpace();
            if (input.charCodeAt(peg$currPos) === 44) {
              s6 = peg$c6;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e6); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parseSpace();
              s5 = [s5, s6, s7];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s4 = peg$parseName();
              if (s4 === peg$FAILED) {
                peg$currPos = s3;
                s3 = peg$FAILED;
              } else {
                s3 = s4;
              }
            } else {
              s3 = s4;
            }
          }
          if (input.charCodeAt(peg$currPos) === 41) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e7); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f7(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseStrOpts() {
        var s0, s1, s2, s3, s4;

        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c8;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e8); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseKVPair();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e6); }
            }
            if (s4 !== peg$FAILED) {
              s4 = peg$parseKVPair();
              if (s4 === peg$FAILED) {
                peg$currPos = s3;
                s3 = peg$FAILED;
              } else {
                s3 = s4;
              }
            } else {
              s3 = s4;
            }
          }
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c8;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e8); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f8(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseKVPair() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        s1 = peg$parseName();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s2 = peg$c9;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e9); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseExC();
            peg$savedPos = s0;
            s0 = peg$f9(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseExC() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e10); }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = input.charAt(peg$currPos);
          if (peg$r0.test(s2)) {
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e10); }
          }
        }
        peg$savedPos = s0;
        s1 = peg$f10(s1);
        s0 = s1;

        return s0;
      }

      function peg$parseName() {
        var s0, s1, s2, s3;

        s0 = peg$currPos;
        s1 = input.charAt(peg$currPos);
        if (peg$r1.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e11); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = input.charAt(peg$currPos);
          if (peg$r2.test(s3)) {
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e12); }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = input.charAt(peg$currPos);
            if (peg$r2.test(s3)) {
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e12); }
            }
          }
          peg$savedPos = s0;
          s0 = peg$f11(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseKeyword() {
        var s0, s1;

        peg$silentFails++;
        s0 = peg$parseTable();
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e13); }
        }

        return s0;
      }

      function peg$parseTable() {
        var s0, s1;

        peg$silentFails++;
        if (input.substr(peg$currPos, 5) === peg$c10) {
          s0 = peg$c10;
          peg$currPos += 5;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e15); }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e14); }
        }

        return s0;
      }

      function peg$parseArrow() {
        var s0;

        if (input.substr(peg$currPos, 2) === peg$c11) {
          s0 = peg$c11;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e16); }
        }

        return s0;
      }

      function peg$parse__() {
        var s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r3.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e17); }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r3.test(s1)) {
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e17); }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseLineBreak() {
        var s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r4.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e18); }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = input.charAt(peg$currPos);
            if (peg$r4.test(s2)) {
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e18); }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f12();
        }
        s0 = s1;

        return s0;
      }

      function peg$parseHardSpace() {
        var s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r5.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e19); }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            s1 = input.charAt(peg$currPos);
            if (peg$r5.test(s1)) {
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$e19); }
            }
          }
        } else {
          s0 = peg$FAILED;
        }

        return s0;
      }

      function peg$parseSpace() {
        var s0, s1;

        s0 = [];
        s1 = input.charAt(peg$currPos);
        if (peg$r5.test(s1)) {
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e19); }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = input.charAt(peg$currPos);
          if (peg$r5.test(s1)) {
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e19); }
          }
        }

        return s0;
      }

      function peg$parse_() {
        var s0, s1, s2;

        peg$silentFails++;
        s0 = peg$currPos;
        s1 = [];
        s2 = input.charAt(peg$currPos);
        if (peg$r3.test(s2)) {
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$e17); }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = input.charAt(peg$currPos);
          if (peg$r3.test(s2)) {
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e17); }
          }
        }
        peg$savedPos = s0;
        s1 = peg$f13();
        s0 = s1;
        peg$silentFails--;
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$e20); }

        return s0;
      }

      peg$result = peg$startRuleFunction();

      if (options.peg$library) {
        return /** @type {any} */ ({
          peg$result,
          peg$currPos,
          peg$FAILED,
          peg$maxFailExpected,
          peg$maxFailPos
        });
      }
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }

    return {
      StartRules: ["Schema"],
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  })()
  ;